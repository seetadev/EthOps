{"version":3,"file":"index.cjs","sources":["../src/errors/createError.ts","../src/errors/errors.ts","../src/util/encoding/stringFromBuffer.ts","../src/util/encoding/textEncoder.ts","../src/util/getWindow.ts","../src/util/encoding/toBase64.ts","../src/util/encoding/toUrlEncodedBase64.ts","../src/util/crypto/getCrypto.ts","../src/util/crypto/getRandomBytes.ts","../src/util/crypto/getCryptoSubtle.ts","../src/util/crypto/sha256.ts","../src/util/crypto/createCodeChallengeAndVerifier.ts","../src/util/encoding/fromBase64.ts","../src/util/encoding/textDecoder.ts","../src/util/uniqueElementsFromArray.ts","../src/util/getSortedScope.ts","../src/util/objectFromURLSearchParams.ts","../src/util/objectToKey.ts","../src/util/index.ts","../src/util/crypto/verifyIdToken.ts","../src/util/encoding/decodeState.ts","../src/util/encoding/encodeState.ts","../src/util/objectFromEntries.ts","../src/util/retry.ts","../src/api/ApiError.ts","../src/api/Api.ts","../src/ClientStore.ts","../src/store/StorageStore.ts","../src/Client.ts","../src/version.ts"],"sourcesContent":["export default function createError(name: string, message: string) {\n  return class extends Error {\n    name = name\n    constructor() {\n      super(message)\n    }\n  }\n}\n","import createError from './createError'\n\nexport const PopupTimeoutError = createError(\n  'PopupTimeoutError',\n  'The popup has timed out.',\n)\n\nexport const PopupClosedError = createError(\n  'PopupClosedError',\n  'The popup was closed.',\n)\n","const stringFromBuffer = (buf: ArrayBuffer): string =>\n  String.fromCharCode.apply(null, Array.from(new Uint8Array(buf)))\n\nexport default stringFromBuffer\n","const textEncoder = new TextEncoder()\n\nexport default textEncoder\n","import window from 'global'\n\nconst getWindow: () => Window & typeof globalThis = () => window\n\nexport default getWindow\n","import getWindow from '../getWindow'\n\nconst toBase64 = (str: string) => getWindow().btoa(str)\n\nexport default toBase64\n","import toBase64 from './toBase64'\n\nconst toUrlEncodedBase64 = (str: string) => {\n  return toBase64(str)\n    .replace(/=+$/g, '')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n}\n\nexport default toUrlEncodedBase64\n","import getWindow from '../getWindow'\n\n//ie 11.x uses msCrypto\nconst getCrypto = () =>\n  (getWindow().crypto ?? (getWindow() as any).msCrypto) as Crypto\n\nexport default getCrypto\n","import getCrypto from './getCrypto'\n\nconst getRandomBytes = (length: number): Uint8Array =>\n  getCrypto().getRandomValues(new Uint8Array(length))\n\nexport default getRandomBytes\n","import getCrypto from './getCrypto'\n\n//safari 10.x uses webkitSubtle\nconst getCryptoSubtle = () =>\n  getCrypto().subtle ?? (getCrypto() as any).webkitSubtle\n\nexport default getCryptoSubtle\n","import getWindow from '../getWindow'\nimport getCryptoSubtle from './getCryptoSubtle'\n\nconst sha256 = async (buf: ArrayBuffer): Promise<ArrayBuffer> => {\n  const digestOp: any = getCryptoSubtle().digest({name: 'SHA-256'}, buf)\n\n  // This is for legacy IE Hashing\n  if ((getWindow() as any).msCrypto) {\n    return new Promise((res, rej) => {\n      digestOp.oncomplete = (e: any) => res(e.target.result)\n      digestOp.onerror = (e: ErrorEvent) => rej(e.error)\n      digestOp.onabort = () => rej('The digest operation was aborted')\n    })\n  }\n\n  return await digestOp\n}\n\nexport default sha256\n","import type {CodeChallengeMethod} from '../../types'\nimport stringFromBuffer from '../encoding/stringFromBuffer'\nimport textEncoder from '../encoding/textEncoder'\nimport toUrlEncodedBase64 from '../encoding/toUrlEncodedBase64'\nimport getRandomBytes from './getRandomBytes'\nimport sha256 from './sha256'\n\nconst pkceMask =\n  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~.'\n\nconst createCodeVerifier = (length: number) => {\n  return Array.from(getRandomBytes(length))\n    .map(v => pkceMask[v % pkceMask.length])\n    .join('')\n}\n\nconst createCodeChallengeAndVerifier = async (\n  length = 43,\n  method: CodeChallengeMethod = 'S256',\n): Promise<{verifier: string; challenge: string}> => {\n  const verifier = createCodeVerifier(length)\n\n  switch (method) {\n    case 'plain':\n      return {verifier, challenge: verifier}\n    case 'S256':\n      return {\n        verifier,\n        challenge: toUrlEncodedBase64(\n          stringFromBuffer(await sha256(textEncoder.encode(verifier).buffer)),\n        ),\n      }\n    default:\n      throw new Error('bad challenge method')\n  }\n}\n\nexport default createCodeChallengeAndVerifier\n","import getWindow from '../getWindow'\n\nconst fromBase64 = (str: string): string => getWindow().atob(str)\n\nexport default fromBase64\n","const textDecoder = new TextDecoder()\n\nexport default textDecoder\n","export default function uniqueElementsFromArray<T>(arr: T[]): T[] {\n  return Array.from(new Set(arr))\n}\n","import uniqueElementsFromArray from './uniqueElementsFromArray'\n\nconst getSortedScope = (scope: string) =>\n  uniqueElementsFromArray(scope.trim().split(/\\s+/)).sort().join(' ')\n\nexport default getSortedScope\n","export default function objectFromURLSearchParams(\n  params: URLSearchParams,\n): Record<string, string | string[]> {\n  const obj = {}\n\n  params.forEach((_, key) => {\n    if (params.getAll(key).length > 1) {\n      obj[key] = params.getAll(key)\n    } else {\n      obj[key] = params.get(key)\n    }\n  })\n\n  return obj\n}\n","export default function objectToKey(object: Record<PropertyKey, any>): string {\n  const params = new URLSearchParams(\n    [...Object.entries(object)].filter(([k, v]) => k != null && v != null),\n  )\n  params.sort()\n  return params.toString()\n}\n","import createCodeChallengeAndVerifier from './crypto/createCodeChallengeAndVerifier'\nimport getCrypto from './crypto/getCrypto'\nimport getCryptoSubtle from './crypto/getCryptoSubtle'\nimport getRandomBytes from './crypto/getRandomBytes'\nimport sha256 from './crypto/sha256'\nimport verifyIdToken from './crypto/verifyIdToken'\nimport decodeState from './encoding/decodeState'\nimport encodeState from './encoding/encodeState'\nimport fromBase64 from './encoding/fromBase64'\nimport stringFromBuffer from './encoding/stringFromBuffer'\nimport textDecoder from './encoding/textDecoder'\nimport textEncoder from './encoding/textEncoder'\nimport toBase64 from './encoding/toBase64'\nimport toUrlEncodedBase64 from './encoding/toUrlEncodedBase64'\n\nconst crypto = {\n  createCodeChallengeAndVerifier,\n  getCrypto,\n  getCryptoSubtle,\n  getRandomBytes,\n  sha256,\n  verifyIdToken,\n}\n\nconst encoding = {\n  decodeState,\n  encodeState,\n  fromBase64,\n  textDecoder,\n  textEncoder,\n  toBase64,\n  toUrlEncodedBase64,\n  stringFromBuffer,\n}\n\nexport {default as getSortedScope} from './getSortedScope'\nexport {default as getWindow} from './getWindow'\nexport {default as objectFromEntries} from './objectFromEntries'\nexport {default as objectFromURLSearchParams} from './objectFromURLSearchParams'\nexport {default as objectToKey} from './objectToKey'\nexport {default as retry} from './retry'\nexport {default as uniqueElementsFromArray} from './uniqueElementsFromArray'\nexport {crypto, encoding}\n","import {IdToken} from '@uauth/common'\nimport {jwtVerify, createRemoteJWKSet} from 'jose'\n\nconst verifyIdToken = async (\n  jwks_uri: string,\n  id_token: string,\n  nonce: string,\n  client_id: string,\n) => {\n  const {payload} = await jwtVerify(\n    id_token,\n    createRemoteJWKSet(new URL(jwks_uri)),\n    {audience: client_id},\n  )\n\n  const idToken: IdToken = payload as any\n\n  idToken.__raw = id_token\n\n  if (nonce !== idToken.nonce) {\n    throw new Error(\"nonces don't match\")\n  }\n\n  return idToken\n}\n\nexport default verifyIdToken\n","import fromBase64 from './fromBase64'\n\nconst decodeState = <T>(state: string): T => {\n  const [, v, ...b] = state.split('.')\n\n  if (b.length > 0) {\n    throw new Error('failed to decode state')\n  }\n\n  return v?.length > 0\n    ? JSON.parse(decodeURIComponent(/* unescape */ fromBase64(v)))\n    : undefined\n}\n\nexport default decodeState\n","import getRandomBytes from '../crypto/getRandomBytes'\nimport stringFromBuffer from './stringFromBuffer'\nimport toUrlEncodedBase64 from './toUrlEncodedBase64'\n\nconst encodeState = <T>(state: T): string =>\n  `${toUrlEncodedBase64(stringFromBuffer(getRandomBytes(32)))}.${\n    state == null\n      ? ''\n      : toUrlEncodedBase64(\n          /* escape */ encodeURIComponent(JSON.stringify(state)),\n        )\n  }`\n\nexport default encodeState\n","export default function objectFromEntries<T = any>(\n  entries: Iterable<readonly [PropertyKey, T]>,\n): Record<PropertyKey, T> {\n  const object: Record<PropertyKey, T> = {}\n  for (const [k, v] of entries) {\n    object[k] = v\n  }\n  return object\n}\n","function retry<T>(\n  fn: () => Promise<T>,\n  retries = 4,\n  timeout = 250,\n  factor = 2,\n  err = null,\n): Promise<T> {\n  if (retries <= 0) {\n    return Promise.reject(err)\n  }\n\n  return fn().catch(async err => {\n    await new Promise(r => setTimeout(r, timeout))\n    return retry(fn, retries - 1, timeout * factor, factor, err)\n  })\n}\n\nexport default retry\n","import {ErrorResponse} from './types'\n\nexport default class ApiError extends Error {\n  constructor(\n    public code: string,\n    public description: string,\n    public uri?: string,\n  ) {\n    super(`${code}: ${description}${uri ? `\\nSee more at ${uri}.` : ''}`)\n  }\n\n  static fromResponse(response: ErrorResponse) {\n    return new ApiError(\n      response.error,\n      response.error_description,\n      response.error_uri,\n    )\n  }\n}\n","import {PopupClosedError, PopupTimeoutError} from '../errors/errors'\nimport {UserInfo} from '../types'\nimport {objectFromURLSearchParams} from '../util'\nimport toBase64 from '../util/encoding/toBase64'\nimport ApiError from './ApiError'\nimport {\n  ApiOptions,\n  AuthorizeRequest,\n  AuthorizeResponse,\n  AuthorizeWithDeviceRequest,\n  AuthorizeWithDeviceResponse,\n  BaseRequest,\n  IntrospectRequest,\n  IntrospectResponse,\n  JWKSRequest,\n  JWKSResponse,\n  LogoutRequest,\n  PopupConfig,\n  RevokeRequest,\n  TokenRequest,\n  TokenResponse,\n  TokenWithAuthorizationCodeRequest,\n  TokenWithClientCredentialsRequest,\n  TokenWithDeviceCodeRequest,\n  TokenWithPasswordRequest,\n  TokenWithRefreshTokenRequest,\n  TokenWithSAMLRequest,\n  UserInfoRequest,\n} from './types'\n\nexport default class Api {\n  static Error = ApiError\n\n  constructor(public options: ApiOptions) {}\n\n  buildAuthorizeUrl(request: AuthorizeRequest): string {\n    return this._buildUrl(request)\n  }\n\n  buildLogoutUrl(request: LogoutRequest): string {\n    return this._buildUrl(request)\n  }\n\n  parseAuthorizeResponseFromFragment(url: string): AuthorizeResponse {\n    return this._validateResponse(\n      objectFromURLSearchParams(\n        new URLSearchParams(new URL(url).hash.substring(1)),\n      ),\n    )\n  }\n\n  parseAuthorizeResponseFromQuery(url: string): AuthorizeResponse {\n    return this._validateResponse(\n      objectFromURLSearchParams(new URL(url).searchParams),\n    )\n  }\n\n  async authorizeWithPopup(\n    request: AuthorizeRequest,\n    config: PopupConfig = {},\n  ): Promise<AuthorizeResponse> {\n    if (!window) {\n      throw new Error('no window in options')\n    }\n\n    const url = this.buildAuthorizeUrl(request)\n\n    let popup: Window | undefined | null = config.popup\n    const timeout: number = config.timeout ?? 3600000\n\n    if (!popup) {\n      const width = config.width ?? 600\n      const height = config.height ?? 800\n\n      popup = window.open(\n        url,\n        'uauth:authorize:popup',\n        `left=${window.screenX + (window.innerWidth - width) / 2},top=${\n          window.screenY + (window.innerHeight - height) / 2\n        },width=${width},height=${height},resizable,scrollbars=yes,status=1`,\n      )\n\n      if (!popup) {\n        throw new Error('popup failed to be constructed')\n      }\n    } else {\n      popup.location.href = url\n    }\n\n    let recievedMessage = false\n    const response: AuthorizeResponse = await new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        if (!recievedMessage) {\n          clearInterval(intervalId)\n          popup!.close()\n          reject(new PopupTimeoutError())\n        }\n      }, timeout)\n\n      const intervalId = setInterval(() => {\n        // Check if popup is closed\n        if (!recievedMessage && popup?.closed) {\n          clearInterval(intervalId)\n          clearTimeout(timeoutId)\n          reject(new PopupClosedError())\n        }\n\n        // Check if popup doesn't violate the \"Same-Origin\" policy and has a valid url\n        let href: string\n        let url: URL\n        let redirectUrl: URL\n        try {\n          href = popup!.location.href\n          url = new URL(href)\n          redirectUrl = new URL(request.redirect_uri)\n        } catch (error) {\n          return // Exit if not\n        }\n\n        // Check to see that the redirect was correct\n        url.hash = ''\n        if (url.href === redirectUrl.href) {\n          recievedMessage = true\n\n          clearInterval(intervalId)\n          clearTimeout(timeoutId)\n          popup!.close()\n\n          try {\n            resolve(this.parseAuthorizeResponseFromFragment(href))\n          } catch (error) {\n            reject(error)\n          }\n        }\n      }, 10)\n    })\n\n    return response\n  }\n\n  async authorizeWithDevice(\n    request: AuthorizeWithDeviceRequest,\n  ): Promise<AuthorizeWithDeviceResponse> {\n    return {} as any\n  }\n\n  async getToken(request: TokenRequest): Promise<TokenResponse> {\n    const [input, init] = this._buildRequest(request, {method: 'POST'})\n    return this._fetchJSON(input, init)\n  }\n\n  introspect(request: IntrospectRequest): Promise<IntrospectResponse> {\n    const [input, init] = this._buildRequest(request, {method: 'POST'})\n    return this._fetchJSON(input, init)\n  }\n\n  async revoke(request: RevokeRequest): Promise<void> {\n    const [input, init] = this._buildRequest(request, {method: 'POST'})\n    await this._fetchJSON(input, init)\n  }\n\n  userinfo(request: UserInfoRequest): Promise<UserInfo> {\n    const [input, init] = this._buildRequest(request, {\n      method: 'GET',\n      headers: {Authorization: `Basic ${request.access_token}`},\n    })\n    return this._fetchJSON(input, init)\n  }\n\n  jwks(request: JWKSRequest): Promise<JWKSResponse> {\n    const [input, init] = this._buildRequest(request, {method: 'GET'})\n    return this._fetchJSON(input, init)\n  }\n\n  getTokenWithAuthorizationCode(\n    request: TokenWithAuthorizationCodeRequest,\n  ): Promise<TokenResponse> {\n    return this.getToken(request)\n  }\n\n  getTokenWithRefreshToken(\n    request: TokenWithRefreshTokenRequest,\n  ): Promise<TokenResponse> {\n    return this.getToken(request)\n  }\n\n  getTokenWithDeviceCode(\n    request: TokenWithDeviceCodeRequest,\n  ): Promise<TokenResponse> {\n    return this.getToken(request)\n  }\n\n  getTokenWithPassword(\n    request: TokenWithPasswordRequest,\n  ): Promise<TokenResponse> {\n    return this.getToken(request)\n  }\n\n  getTokenWithSAML(request: TokenWithSAMLRequest): Promise<TokenResponse> {\n    return this.getToken(request)\n  }\n\n  getTokenWithClientCredentials(\n    request: TokenWithClientCredentialsRequest,\n  ): Promise<TokenResponse> {\n    return this.getToken(request)\n  }\n\n  private _buildUrl(request: BaseRequest): string {\n    const {url, ...searchParams} = request\n\n    const urlObject = new URL(url)\n\n    const params = new URLSearchParams()\n\n    for (const [k, v] of Object.entries(searchParams)) {\n      if (k != null && v != null) {\n        params.append(k, v)\n      }\n    }\n\n    urlObject.search = params.toString()\n    return urlObject.toString()\n  }\n\n  private _buildRequest(\n    request: BaseRequest,\n    options: {method: 'GET' | 'POST'; headers?: HeadersInit},\n  ): [RequestInfo, RequestInit] {\n    const {url, client_id, client_secret, client_auth_method, ...rest} = request\n    const {headers: headersInit, method} = options\n\n    const headers = new Headers(this.options.headers ?? [])\n\n    new Headers(headersInit ?? []).forEach((value, key) => {\n      headers.set(key, value)\n    })\n\n    if (options.method === 'POST') {\n      headers.set('Content-Type', 'application/x-www-form-urlencoded')\n    }\n\n    const body: Record<string, any> = {\n      client_id,\n      ...rest,\n    }\n\n    switch (client_auth_method) {\n      case 'client_secret_basic':\n        // throw new Error('only client_secret_post supported')\n        if (client_secret == null) {\n          throw new Error('Client secret not present!')\n        }\n\n        headers.set(\n          'Authorization',\n          `Basic ${toBase64(`${client_id}:${client_secret}`)}`,\n        )\n\n        break\n      case 'client_secret_post':\n        if (client_secret == null) {\n          throw new Error('Client secret not present!')\n        }\n\n        body.client_secret = client_secret\n\n        break\n      case 'none':\n      case undefined:\n      case null:\n        break\n      default:\n        throw new Error('Bad client_auth_method')\n    }\n\n    return [\n      url,\n      {\n        method,\n        headers,\n        body:\n          method === 'POST'\n            ? new URLSearchParams(Object.entries(body))\n            : undefined,\n      },\n    ]\n  }\n\n  private _validateResponse(response: any) {\n    if (response.error) {\n      throw Api.Error.fromResponse(response)\n    }\n\n    return response\n  }\n\n  private async _fetchJSON(\n    input: RequestInfo,\n    init: RequestInit,\n  ): Promise<any> {\n    if (init.headers) {\n      const headers = new Headers(init.headers)\n      headers.set('Accept', 'application/json')\n      init.headers = headers\n    } else {\n      init.headers = {Accept: 'application/json'}\n    }\n\n    const response = await window?.fetch(input, init)\n\n    const json = await response.json()\n    this._validateResponse(json)\n\n    if (!response.ok) {\n      throw new Error(\n        `${response.status} ${response.statusText}: ${JSON.stringify(json)}`,\n      )\n    }\n\n    return json\n  }\n}\n","import {AuthorizeRequest, LogoutRequest} from './api'\nimport type Client from './Client'\nimport {Authorization, AuthorizationOptions} from './types'\nimport * as util from './util'\n\nclass ClientStore {\n  constructor(public client: Client) {}\n\n  private async get<T>(\n    key: string,\n    {mustExist = false, deleteAfter = false} = {},\n  ): Promise<T | undefined> {\n    const entry = await this.client.getStore().get(key)\n    if (entry == null) {\n      if (mustExist) {\n        throw new Error(`${key} does not exist in store`)\n      }\n      return\n    }\n\n    const {value, expiresAt} = entry\n    if (expiresAt !== 0 && expiresAt < Date.now()) {\n      await this.client.getStore().delete(key)\n      if (mustExist) {\n        throw new Error(`${key} does not exist in store`)\n      }\n      return\n    }\n\n    if (deleteAfter) {\n      await this.client.getStore().delete(key)\n    }\n\n    return value\n  }\n\n  private async set<T>(key: string, value: any, timeout = 0) {\n    await this.client.getStore().set(key, {\n      expiresAt: timeout === 0 ? 0 : Date.now() + timeout,\n      value,\n    })\n  }\n\n  async setAuthorizeRequest(request: AuthorizeRequest): Promise<void> {\n    await this.set('request', request, 300_000 /* 5 minutes */)\n  }\n  getAuthorizeRequest(): Promise<AuthorizeRequest> {\n    return this.get<AuthorizeRequest>('request', {\n      mustExist: true,\n      deleteAfter: true,\n    }) as Promise<AuthorizeRequest>\n  }\n\n  async setLogoutRequest(request: LogoutRequest): Promise<void> {\n    await this.set('logout-request', request, 300_000 /* 5 minutes */)\n  }\n  getLogoutRequest(): Promise<LogoutRequest> {\n    return this.get<LogoutRequest>('logout-request', {\n      mustExist: true,\n      deleteAfter: true,\n    }) as Promise<LogoutRequest>\n  }\n\n  async setVerifier(challenge: string, verifier: string): Promise<void> {\n    await this.set(`verifier:${challenge}`, verifier, 300_000 /* 5 minutes */)\n  }\n  getVerifier(challenge: string): Promise<string> {\n    return this.get(`verifier:${challenge}`, {\n      mustExist: true,\n      deleteAfter: true,\n    }) as Promise<string>\n  }\n\n  async setOpenIdConfiguration(\n    username: string,\n    openidConfiguration: any,\n    timeout: number,\n  ): Promise<void> {\n    await this.set(\n      `openidConfiguration:${username}`,\n      openidConfiguration,\n      timeout,\n    )\n  }\n  getOpenIdConfiguration(username: string): Promise<any> {\n    return this.get(`openidConfiguration:${username}`)\n  }\n\n  async setAuthorization(authorization: Authorization): Promise<void> {\n    const authorizationOptions: AuthorizationOptions = {\n      clientID: authorization.idToken.aud,\n      resource: authorization.resource,\n      scope: authorization.scope,\n      username: authorization.idToken.sub,\n    }\n\n    const expiresIn = authorization.expiresAt - Date.now()\n\n    await this.set('username', authorizationOptions.username, expiresIn)\n    await this.set(\n      await this._getAuthorizationKey(authorizationOptions),\n      authorization,\n      expiresIn,\n    )\n  }\n  async deleteAuthorization(options: AuthorizationOptions): Promise<boolean> {\n    const fallbackUsername = await this.get<string>('username')\n\n    options.username = await this._getUsername(\n      options.username,\n      fallbackUsername,\n    )\n\n    if (options.username === fallbackUsername) {\n      await this.client.getStore().delete('username')\n    }\n\n    return this.client\n      .getStore()\n      .delete(await this._getAuthorizationKey(options))\n  }\n  async getAuthorization(\n    options: AuthorizationOptions,\n  ): Promise<Authorization> {\n    return this.get(await this._getAuthorizationKey(options), {\n      mustExist: true,\n    }) as Promise<Authorization>\n  }\n\n  private async _getAuthorizationKey(\n    options: AuthorizationOptions,\n  ): Promise<string> {\n    return `authorization?${util.objectToKey({\n      username: await this._getUsername(\n        options.username,\n        await this.get('username'),\n      ),\n      clientID: options.clientID ?? this.client.fallbackLoginOptions.clientID,\n      scope: util.getSortedScope(\n        options.scope ?? this.client.fallbackLoginOptions.scope,\n      ),\n      resource: options.resource ?? this.client.fallbackLoginOptions.resource,\n    })}`\n  }\n\n  private async _getUsername(username?: string, fallbackUsername?: string) {\n    if (username == null && fallbackUsername == null) {\n      throw new Error('no username given')\n    }\n\n    return username ?? fallbackUsername\n  }\n}\n\nexport default ClientStore\n","import {Store} from './types'\n\nexport default class StorageStore implements Store {\n  constructor(public storage: Storage) {}\n\n  get(key: string): string | null {\n    const value = this.storage.getItem(key)\n\n    if (value != null) {\n      return JSON.parse(value)\n    }\n\n    return null\n  }\n\n  delete(key: string): boolean {\n    this.storage.removeItem(key)\n    return true\n  }\n\n  set(key: string, value): this {\n    this.storage.setItem(key, JSON.stringify(value))\n    return this\n  }\n}\n","import {\n  DefaultIPFSResolver,\n  DefaultIssuerResolver,\n  DefaultWebFingerResolver,\n  DomainResolver,\n  IssuerResolver,\n} from '@uauth/common'\nimport {\n  Resolution,\n  ResolutionError,\n  ResolutionErrorCode,\n} from '@unstoppabledomains/resolution'\nimport {\n  Api,\n  AuthorizeRequest,\n  AuthorizeResponse,\n  LogoutRequest,\n  LogoutResponse,\n  PopupConfig,\n  TokenResponse,\n  TokenWithAuthorizationCodeRequest,\n  UserInfoRequest,\n} from './api'\nimport ClientStore from './ClientStore'\nimport {StorageStore, Store, StoreType} from './store'\nimport {\n  Authorization,\n  AuthorizationOptions,\n  VerifiedAddress,\n  BaseLoginOptions,\n  BaseLogoutOptions,\n  CacheOptions,\n  ClientOptions,\n  FullLoginOptions,\n  LoginCallbackOptions,\n  LoginCallbackResponse,\n  LoginOptions,\n  LogoutCallbackOptions,\n  LogoutOptions,\n  UserInfo,\n  UserOptions,\n} from './types'\nimport * as util from './util'\nimport {VERSION} from './version'\n\nif (typeof window !== 'undefined') {\n  const _w = window as any\n  _w.UAUTH_VERSION = _w.UAUTH_VERSION || {}\n  _w.UAUTH_VERSION.JS = VERSION\n}\n\nexport default class Client {\n  util = util\n  private _clientStore = new ClientStore(this)\n  api: Api\n  fallbackIssuer: string\n  fallbackLoginOptions: BaseLoginOptions\n  fallbackLogoutOptions: BaseLogoutOptions\n  cacheOptions: CacheOptions\n  issuerResolver: IssuerResolver\n  resolution: DomainResolver\n\n  store?: Store\n  storeOptions: {\n    store?: Store\n    storeType: StoreType\n  }\n\n  getStore(): Store {\n    if (this.store) {\n      return this.store\n    }\n\n    if (this.storeOptions.store) {\n      this.store = this.storeOptions.store\n    } else {\n      const storeType = this.storeOptions.storeType\n      switch (storeType) {\n        case 'localstore':\n          this.store = new StorageStore(window.localStorage)\n          break\n        case 'sessionstore':\n          this.store = new StorageStore(window.sessionStorage)\n          break\n        case 'memory':\n          this.store = new Map<string, string>()\n          break\n        default:\n          throw new Error('Bad storeType provided')\n      }\n    }\n\n    return this.store\n  }\n\n  constructor(options: ClientOptions) {\n    this.fallbackIssuer =\n      options.fallbackIssuer ?? 'https://auth.unstoppabledomains.com'\n    this.resolution = options.resolution ?? new Resolution()\n\n    this.storeOptions = {\n      store: options.store,\n      storeType: options.storeType ?? 'localstore',\n    }\n\n    this.cacheOptions = {\n      issuer: false,\n      userinfo: true,\n      ...(options.cacheOptions ?? {}),\n    }\n\n    this.api = new Api({\n      headers: {},\n    })\n\n    this.fallbackLoginOptions = {\n      clientID: options.clientID,\n      clientSecret: options.clientSecret,\n      clientAuthMethod:\n        options.clientAuthMethod ??\n        (options.clientSecret ? 'client_secret_post' : 'none'),\n      maxAge: options.maxAge ?? 300000,\n      prompt: options.prompt ?? 'login',\n      resource: options.resource,\n      redirectUri: options.redirectUri,\n      responseMode: options.responseMode ?? 'fragment',\n      scope: options.scope ?? 'openid wallet',\n    }\n\n    this.fallbackLogoutOptions = {\n      rpInitiatedLogout:\n        options.rpInitiatedLogout ??\n        typeof options.postLogoutRedirectUri === 'string',\n      postLogoutRedirectUri: options.postLogoutRedirectUri,\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    this.issuerResolver = new DefaultIssuerResolver({\n      webfingerResolver: new DefaultWebFingerResolver({\n        ipfsResolver: new DefaultIPFSResolver((...args) =>\n          (options.createIpfsUrl || DefaultIPFSResolver.defaultCreateUrl)(\n            ...args,\n          ),\n        ),\n        domainResolver: {\n          async records(\n            domain: string,\n            keys: string[],\n          ): Promise<Record<string, string>> {\n            try {\n              const records = await self.resolution.records(domain, keys)\n              return records\n            } catch (error) {\n              if (\n                error instanceof ResolutionError &&\n                error.code === ResolutionErrorCode.UnspecifiedResolver\n              ) {\n                return {}\n              }\n              throw error\n            }\n          },\n        },\n      }),\n    })\n  }\n\n  async buildAuthorizeRequest(\n    options: Partial<LoginOptions>,\n  ): Promise<AuthorizeRequest> {\n    // TODO: Ensure nothing is missing\n    const loginOptions: FullLoginOptions = {\n      ...this.fallbackLoginOptions,\n      ...options,\n    } as FullLoginOptions\n\n    const loginHint = options.username\n\n    const openidConfiguration = await this.getOpenIdConfiguration(loginHint)\n\n    const {verifier, challenge} =\n      await util.crypto.createCodeChallengeAndVerifier(43, 'S256')\n\n    const nonce = util.encoding.toBase64(\n      util.encoding.stringFromBuffer(util.crypto.getRandomBytes(32)),\n\n      /* util.encoding.textDecoder.decode */\n    )\n\n    const state = util.encoding.encodeState(loginOptions.state)\n\n    const request: AuthorizeRequest = {\n      // Generated options\n      url: openidConfiguration.authorization_endpoint,\n      code_challenge: challenge,\n      nonce,\n      state,\n\n      // Builder options\n      flow_id: loginOptions.flowId ?? 'login',\n      login_hint: loginHint,\n\n      // Parameterized options\n      client_id: loginOptions.clientID,\n      client_secret: loginOptions.clientSecret,\n      client_auth_method: loginOptions.clientAuthMethod,\n      max_age: loginOptions.maxAge,\n      prompt: loginOptions.prompt,\n      resource: loginOptions.resource,\n      redirect_uri: loginOptions.redirectUri,\n      response_mode: loginOptions.responseMode,\n      scope: loginOptions.scope,\n\n      // Constant options\n      code_challenge_method: 'S256',\n      response_type: 'code',\n\n      // package info\n      package_name: loginOptions?.packageName || '@uauth/js',\n      package_version: loginOptions?.packageVersion || VERSION,\n    }\n\n    await this._clientStore.setAuthorizeRequest(request)\n    await this._clientStore.setVerifier(challenge, verifier)\n\n    return request\n  }\n\n  async loginWithPopup(\n    options: Partial<Omit<LoginOptions, 'responseMode'>> = {},\n    config?: PopupConfig,\n  ): Promise<Authorization> {\n    ;(options as Partial<LoginOptions>).responseMode = 'fragment'\n    const request = await this.buildAuthorizeRequest(options)\n    const response = await this.api.authorizeWithPopup(request, config)\n    const authorization = await this.verifyAuthorizeResponse(request, response)\n\n    return authorization\n  }\n\n  async login(options: Partial<LoginOptions> = {}): Promise<void> {\n    const request: AuthorizeRequest = await this.buildAuthorizeRequest(options)\n\n    const url = this.api.buildAuthorizeUrl(request)\n\n    if (typeof options.beforeRedirect === 'function') {\n      await options.beforeRedirect(url)\n    }\n\n    window.location.href = url\n  }\n\n  async loginCallback<T>(\n    options?: Partial<LoginCallbackOptions>,\n  ): Promise<LoginCallbackResponse<T>> {\n    const url = options?.url ?? window.location.href\n\n    const request: AuthorizeRequest =\n      await this._clientStore.getAuthorizeRequest()\n\n    let response: AuthorizeResponse\n    if (request.response_mode === 'fragment') {\n      response = this.api.parseAuthorizeResponseFromFragment(url)\n    } else if (request.response_mode === 'query') {\n      response = this.api.parseAuthorizeResponseFromQuery(url)\n    } else {\n      throw new Error('Unsupported response_mode')\n    }\n\n    return {\n      authorization: await this.verifyAuthorizeResponse(request, response),\n      state: util.encoding.decodeState<T>(request.state),\n    }\n  }\n\n  async verifyAuthorizeResponse(\n    request: AuthorizeRequest,\n    response: AuthorizeResponse,\n  ): Promise<Authorization> {\n    if (request.state !== response.state) {\n      throw new Error(\"states don't match\")\n    }\n\n    const openidConfiguration = await this.getOpenIdConfiguration(\n      request.login_hint,\n    )\n\n    const tokenRequest: TokenWithAuthorizationCodeRequest = {\n      url: openidConfiguration.token_endpoint,\n      client_id: request.client_id,\n      client_secret: request.client_secret,\n      client_auth_method: request.client_auth_method,\n      grant_type: 'authorization_code',\n      code: response.code,\n      code_verifier: await this._clientStore.getVerifier(\n        request.code_challenge,\n      ),\n      redirect_uri: request.redirect_uri,\n    }\n\n    const tokenResponse: TokenResponse =\n      await this.api.getTokenWithAuthorizationCode(tokenRequest)\n\n    const idToken = await util.crypto.verifyIdToken(\n      openidConfiguration.jwks_uri,\n      tokenResponse.id_token!,\n      request.nonce,\n      request.client_id,\n    )\n\n    const authorization: Authorization = {\n      accessToken: tokenResponse.access_token,\n      // TODO: The server isn't returning the scope along with the callback and\n      // I havn't found the oidc docs to figure out if this is a bug.\n      expiresAt: Date.now() + tokenResponse.expires_in * 1000,\n      idToken,\n      scope: util.getSortedScope(request.scope),\n      resource: request.resource,\n    }\n\n    await this._clientStore.setAuthorization(authorization)\n\n    return authorization\n  }\n\n  // getVerifiedAccounts retrieves all verified accounts associated with the domain\n  getVerifiedAccounts(\n    authorization: Authorization,\n    symbols: string[] = [],\n  ): VerifiedAddress[] {\n    // ensure the authorization includes verified_addresses field\n    const verifiedAddresses: VerifiedAddress[] = []\n    if (!authorization.idToken.verified_addresses) {\n      return verifiedAddresses\n    }\n    authorization.idToken.verified_addresses.forEach((record: any) => {\n      // filter for requested symbols if provided\n      if (symbols.length > 0 && !symbols.includes(record.symbol)) {\n        return\n      }\n      // include the verified address\n      verifiedAddresses.push({\n        address: record.address,\n        message: record.proof.message,\n        signature: record.proof.signature,\n        symbol: record.symbol,\n      })\n    })\n\n    // return the verified address list\n    return verifiedAddresses\n  }\n\n  // getAuthorizationAccount retrieves the address that authorized the request\n  getAuthorizationAccount(\n    authorization: Authorization,\n    type = 'sig',\n    version = 'v1',\n  ): VerifiedAddress | undefined {\n    // find the requested proof key from AMR field\n    const sigProofKeys = authorization.idToken.amr?.filter((key: string) =>\n      key.startsWith(`${version}.${type}`),\n    )\n\n    // validate the proof key is located\n    if (!sigProofKeys || sigProofKeys.length == 0) {\n      return undefined\n    }\n\n    // extract the signature address\n    const sigAddress = sigProofKeys[0].split('.')[3]\n    const verifiedAccounts = this.getVerifiedAccounts(authorization)\n    if (!verifiedAccounts) {\n      return undefined\n    }\n\n    // find and return the proof address from verified account list\n    for (const account of verifiedAccounts) {\n      if (account.address === sigAddress) {\n        return account\n      }\n    }\n  }\n\n  async getOpenIdConfiguration(username?: string): Promise<any> {\n    if (this.cacheOptions.issuer) {\n      const openidConfiguration =\n        await this._clientStore.getOpenIdConfiguration(username ?? '')\n      if (openidConfiguration) {\n        return openidConfiguration\n      }\n    }\n\n    const openidConfiguration = username\n      ? await this.issuerResolver.resolve(username, this.fallbackIssuer)\n      : await fetch(\n          this.fallbackIssuer + '/.well-known/openid-configuration',\n        ).then(resp =>\n          resp.ok\n            ? resp.json()\n            : Promise.reject(new Error('bad openid-configuration response')),\n        )\n\n    await this._clientStore.setOpenIdConfiguration(\n      username ?? '',\n      openidConfiguration,\n      typeof this.cacheOptions.issuer === 'number'\n        ? this.cacheOptions.issuer\n        : 3600_000,\n    )\n\n    return openidConfiguration\n  }\n\n  async authorization(\n    options: AuthorizationOptions = {},\n  ): Promise<Authorization> {\n    return this._clientStore.getAuthorization(options)\n  }\n\n  async user(options: UserOptions = {}): Promise<UserInfo> {\n    const claims = options.claims ?? [\n      'name',\n      'given_name',\n      'family_name',\n      'middle_name',\n      'nickname',\n      'preferred_username',\n      'profile',\n      'picture',\n      'website',\n      'email',\n      'email_verified',\n      'gender',\n      'birthdate',\n      'zoneinfo',\n      'locale',\n      'phone_number',\n      'phone_number_verified',\n      'address',\n      'updated_at',\n      'wallet_address',\n      'wallet_type_hint',\n      'eip4361_message',\n      'eip4361_signature',\n      'humanity_check_id',\n    ]\n\n    const authorization = await this.authorization(options)\n\n    const userinfo: UserInfo = {\n      sub: authorization.idToken.sub,\n    }\n\n    // If we should only read from cache.\n    if (this.cacheOptions.userinfo) {\n      for (const claim of claims) {\n        if (authorization.idToken[claim]) {\n          userinfo[claim] = authorization.idToken[claim]\n        }\n      }\n\n      return userinfo\n    }\n\n    const openidConfiguration = await this.getOpenIdConfiguration(\n      authorization.idToken.sub,\n    )\n\n    const request: UserInfoRequest = {\n      client_id: this.fallbackLoginOptions.clientID,\n      client_secret: this.fallbackLoginOptions.clientSecret,\n      client_auth_method: this.fallbackLoginOptions.clientAuthMethod,\n      access_token: authorization.accessToken,\n      url: openidConfiguration.userinfo_endpoint,\n    }\n\n    const response = await this.api.userinfo(request)\n\n    for (const claim of claims) {\n      if (response[claim]) {\n        userinfo[claim] = response[claim]\n      }\n    }\n\n    return userinfo\n  }\n\n  async buildLogoutRequest(options: LogoutOptions): Promise<LogoutRequest> {\n    const authorization = await this.authorization(options)\n\n    const openidConfiguration = await this.getOpenIdConfiguration(\n      authorization.idToken.sub,\n    )\n\n    if (openidConfiguration.end_session_endpoint == null) {\n      throw new Error('end_session_endpoint must exist')\n    }\n\n    const postLogoutRedirectUri =\n      options.postLogoutRedirectUri ??\n      this.fallbackLogoutOptions.postLogoutRedirectUri\n\n    if (postLogoutRedirectUri == null) {\n      throw new Error('postLogoutRedirectUri must be supplied')\n    }\n\n    const request: LogoutRequest = {\n      client_id: this.fallbackLoginOptions.clientID,\n      client_secret: this.fallbackLoginOptions.clientSecret,\n      client_auth_method: this.fallbackLoginOptions.clientAuthMethod,\n      url: openidConfiguration.end_session_endpoint,\n      id_token_hint: authorization.idToken.__raw,\n      post_logout_redirect_uri: postLogoutRedirectUri,\n      state: util.encoding.encodeState(options.state),\n    }\n\n    await this._clientStore.setLogoutRequest(request)\n\n    return request\n  }\n\n  async logout({\n    clientID,\n    username,\n    scope,\n    resource,\n    ...options\n  }: Partial<LogoutOptions> = {}): Promise<void> {\n    const logoutOptions: LogoutOptions = {\n      ...this.fallbackLogoutOptions,\n      ...options,\n    }\n\n    const authorizationOptions = {clientID, username, scope, resource}\n\n    if (!logoutOptions.rpInitiatedLogout) {\n      await this._clientStore.deleteAuthorization(authorizationOptions)\n      return\n    }\n\n    const request = await this.buildLogoutRequest(logoutOptions)\n\n    const url = this.api.buildLogoutUrl(request)\n\n    if (typeof logoutOptions.beforeRedirect === 'function') {\n      await logoutOptions.beforeRedirect(url)\n    }\n\n    await this._clientStore.deleteAuthorization(authorizationOptions)\n\n    window.location.href = url\n  }\n\n  async logoutCallback<T>(options: LogoutCallbackOptions = {}): Promise<T> {\n    const url = options?.url ?? window.location.href\n\n    const request: LogoutRequest = await this._clientStore.getLogoutRequest()\n\n    const response: AuthorizeResponse =\n      this.api.parseAuthorizeResponseFromQuery(url)\n\n    await this.verifyLogoutResponse(request, response)\n\n    return util.encoding.decodeState<T>(request.state)\n  }\n\n  async verifyLogoutResponse(\n    request: LogoutRequest,\n    response: LogoutResponse,\n  ): Promise<void> {\n    if (request.state !== response.state) {\n      throw new Error(\"states don't match\")\n    }\n  }\n}\n","export const VERSION = \"2.4.0\";\n"],"names":["createError","name","message","_Error","_class2","_this","this","_inheritsLoose","Error","PopupTimeoutError","PopupClosedError","stringFromBuffer","buf","String","fromCharCode","apply","Array","from","Uint8Array","textEncoder","TextEncoder","getWindow","window","toBase64","str","btoa","toUrlEncodedBase64","replace","getCrypto","crypto","_getWindow$crypto","msCrypto","getRandomBytes","length","getRandomValues","getCryptoSubtle","subtle","_getCrypto$subtle","webkitSubtle","sha256","digestOp","digest","Promise","resolve","res","rej","oncomplete","e","target","result","onerror","error","onabort","reject","pkceMask","fromBase64","atob","textDecoder","TextDecoder","uniqueElementsFromArray","arr","Set","getSortedScope","scope","trim","split","sort","join","objectFromURLSearchParams","params","obj","forEach","_","key","getAll","get","objectToKey","object","URLSearchParams","Object","entries","filter","_ref","toString","createCodeChallengeAndVerifier","method","verifier","map","v","createCodeVerifier","challenge","encode","buffer","then","_sha","verifyIdToken","jwks_uri","id_token","nonce","client_id","jwtVerify","createRemoteJWKSet","URL","audience","payload","idToken","__raw","encoding","decodeState","state","_state$split","slice","JSON","parse","decodeURIComponent","undefined","encodeState","encodeURIComponent","stringify","objectFromEntries","_step","_iterator","done","_step$value","value","retry","fn","retries","timeout","factor","err","r","setTimeout","ApiError","code","description","uri","fromResponse","response","error_description","error_uri","_excluded","_excluded2","Api","options","buildAuthorizeUrl","request","_buildUrl","buildLogoutUrl","parseAuthorizeResponseFromFragment","url","_validateResponse","hash","substring","parseAuthorizeResponseFromQuery","searchParams","authorizeWithPopup","config","_config$timeout","_this2","popup","location","href","_config$width","_config$height","width","height","open","screenX","innerWidth","screenY","innerHeight","recievedMessage","timeoutId","clearInterval","intervalId","close","setInterval","redirectUrl","_popup","closed","clearTimeout","redirect_uri","authorizeWithDevice","getToken","_buildRequest","_fetchJSON","_this4$_buildRequest","introspect","_this$_buildRequest","init","revoke","_this6$_buildRequest","userinfo","_this$_buildRequest2","headers","Authorization","access_token","jwks","_this$_buildRequest3","getTokenWithAuthorizationCode","getTokenWithRefreshToken","getTokenWithDeviceCode","getTokenWithPassword","getTokenWithSAML","getTokenWithClientCredentials","_objectWithoutPropertiesLoose","urlObject","_i","_Object$entries","_Object$entries$_i","k","append","search","_this$options$headers","client_secret","client_auth_method","rest","headersInit","Headers","set","body","input","_window","_this8","Accept","fetch","json","ok","status","statusText","ClientStore","client","mustExist","_ref$mustExist","deleteAfter","getStore","entry","_exit","_temp3","_result","_temp","expiresAt","Date","now","_temp2","setAuthorizeRequest","getAuthorizeRequest","setLogoutRequest","getLogoutRequest","setVerifier","getVerifier","setOpenIdConfiguration","username","openidConfiguration","getOpenIdConfiguration","setAuthorization","authorization","_this14","authorizationOptions","clientID","aud","resource","sub","expiresIn","_set","_getAuthorizationKey","_this13$_getAuthoriza","call","deleteAuthorization","_this16","fallbackUsername","_getUsername","_this15$_getUsername","_temp6","_this15$client$getSto","_delete","_this15$_getAuthoriza","_temp5","getAuthorization","_get2","_this18","_this17$_getAuthoriza","_this20","util","_getUsername3","_this19$_getUsername","_options$clientID","fallbackLoginOptions","_options$resource","StorageStore","storage","getItem","_proto","removeItem","setItem","_w","UAUTH_VERSION","JS","_options$fallbackIssu","_options$resolution","_options$storeType","_options$cacheOptions","_options$clientAuthMe","_options$maxAge","_options$prompt","_options$responseMode","_options$scope","_options$rpInitiatedL","_clientStore","api","fallbackIssuer","fallbackLogoutOptions","cacheOptions","issuerResolver","resolution","store","storeOptions","Resolution","storeType","issuer","clientSecret","clientAuthMethod","maxAge","prompt","redirectUri","responseMode","rpInitiatedLogout","postLogoutRedirectUri","self","DefaultIssuerResolver","webfingerResolver","DefaultWebFingerResolver","ipfsResolver","DefaultIPFSResolver","createIpfsUrl","defaultCreateUrl","arguments","domainResolver","records","domain","keys","_catch","ResolutionError","ResolutionErrorCode","UnspecifiedResolver","localStorage","sessionStorage","Map","buildAuthorizeRequest","loginOptions","_extends","loginHint","_loginOptions$flowId","authorization_endpoint","code_challenge","flow_id","flowId","login_hint","max_age","response_mode","code_challenge_method","response_type","package_name","packageName","package_version","packageVersion","loginWithPopup","_this4","verifyAuthorizeResponse","login","_this6","beforeRedirect","loginCallback","_options$url","_this7$verifyAuthoriz","_this10","_response$code","_request$client_auth_","token_endpoint","_this9$_clientStore$g","_openidConfiguration$","_request$client_id","_request$client_secre","grant_type","code_verifier","tokenResponse","accessToken","expires_in","getVerifiedAccounts","symbols","verifiedAddresses","verified_addresses","record","includes","symbol","push","address","proof","signature","getAuthorizationAccount","type","version","_authorization$idToke","sigProofKeys","amr","startsWith","sigAddress","verifiedAccounts","account","_exit2","_this12","resp","user","_options$claims","claims","claim","_step2","userinfo_endpoint","_step3","_iterator3","buildLogoutRequest","_options$postLogoutRe","end_session_endpoint","id_token_hint","post_logout_redirect_uri","logout","_exit4","_temp12","_result2","logoutOptions","_temp8","_temp7","_temp13","logoutCallback","_options$url2","_options","_this22","verifyLogoutResponse"],"mappings":"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"}