import { AutoNetworkConfigs, CryptoRecords, DnsRecord, DnsRecordType, EthersProvider, Locations, NamehashOptions, NamingServiceName, Provider, SourceConfig, TokenUriMetadata, Web3Version0Provider, Web3Version1Provider, ReverseResolutionOptions } from './types/publicTypes';
import { UnsSupportedNetwork } from './types';
/**
 * Blockchain domain Resolution library - Resolution.
 * @example
 * ```
 * import Resolution from '@unstoppabledomains/resolution';
 *
 * let resolution = new Resolution({ blockchain: {
 *        uns: {
 *           url: "https://eth-mainnet.alchemyapi.io/v2/GmQ8X1FHf-WDEry0BBSn0RgjVhjHkRmS",
 *           network: "mainnet"
 *        }
 *      }
 *   });
 *
 * let domain = "brad.zil";
 * resolution.addr(domain, "eth").then(addr => console.log(addr));;
 * ```
 */
export default class Resolution {
    constructor({ sourceConfig }?: {
        sourceConfig?: SourceConfig;
    });
    /**
     * AutoConfigure the blockchain network for UNS
     * We make a "net_version" JSON RPC call to the blockchain either via url or with the help of given provider.
     * @param sourceConfig - configuration object for uns
     * @returns configured Resolution object
     */
    static autoNetwork(sourceConfig: AutoNetworkConfigs): Promise<Resolution>;
    /**
     * Creates a resolution with configured infura id for uns
     * @param infura - infura project id
     * @param networks - an optional object that describes what network to use when connecting UNS default is mainnet
     */
    static infura(infura: string, networks?: {
        uns?: {
            locations: {
                Layer1: {
                    network: UnsSupportedNetwork;
                };
                Layer2: {
                    network: UnsSupportedNetwork;
                };
            };
        };
    }): Resolution;
    /**
     * Creates a resolution with configured alchemy API keys for uns
     * @param alchemy - alchemy API keys
     * @param networks - an optional object that describes what network to use when connecting UNS default is mainnet
     */
    static alchemy(alchemy: string, networks?: {
        uns?: {
            locations: {
                Layer1: {
                    network: UnsSupportedNetwork;
                };
                Layer2: {
                    network: UnsSupportedNetwork;
                };
            };
        };
    }): Resolution;
    /**
     * Creates a resolution instance with configured provider
     * @param networks - an object that describes what network to use when connecting UNS or ZNS default is mainnet
     * @see https://eips.ethereum.org/EIPS/eip-1193
     */
    static fromResolutionProvider(networks: {
        uns?: {
            locations: {
                Layer1: {
                    provider: Provider;
                    network: string;
                };
                Layer2: {
                    provider: Provider;
                    network: string;
                };
            };
        };
        zns?: {
            provider: Provider;
            network: string;
        };
    }): Resolution;
    /**
     * Creates a resolution instance with configured provider
     * @param networks - an object that describes what network to use when connecting UNS default is mainnet
     * @see https://eips.ethereum.org/EIPS/eip-1193
     */
    static fromEthereumEip1193Provider(networks: {
        uns?: {
            locations: {
                Layer1: {
                    provider: Provider;
                    network?: string;
                };
                Layer2: {
                    provider: Provider;
                    network?: string;
                };
            };
        };
    }): Resolution;
    /**
     * Creates a resolution instance with configured provider
     * @param provider - any provider compatible with EIP-1193
     * @param networks - an optional object that describes what network to use when connecting ZNS default is mainnet
     * @see https://eips.ethereum.org/EIPS/eip-1193
     */
    static fromZilliqaProvider(provider: Provider, networks?: {
        zns?: {
            network: string;
        };
    }): Resolution;
    /**
     * Create a resolution instance from web3 0.x version provider
     * @param networks - Ethereum network configuration with 0.x version provider from web3 ( must implement sendAsync(payload, callback) )
     * @see https://github.com/ethereum/web3.js/blob/0.20.7/lib/web3/httpprovider.js#L116
     */
    static fromWeb3Version0Provider(networks: {
        uns?: {
            locations: {
                Layer1: {
                    provider: Web3Version0Provider;
                    network: string;
                };
                Layer2: {
                    provider: Web3Version0Provider;
                    network: string;
                };
            };
        };
    }): Resolution;
    /**
     * Create a resolution instance from web3 1.x version provider
     * @param networks - an optional object with 1.x version provider from web3 ( must implement send(payload, callback) ) that describes what network to use when connecting UNS default is mainnet
     * @see https://github.com/ethereum/web3.js/blob/1.x/packages/web3-core-helpers/types/index.d.ts#L165
     * @see https://github.com/ethereum/web3.js/blob/1.x/packages/web3-providers-http/src/index.js#L95
     */
    static fromWeb3Version1Provider(networks: {
        uns?: {
            locations: {
                Layer1: {
                    provider: Web3Version1Provider;
                    network: string;
                };
                Layer2: {
                    provider: Web3Version1Provider;
                    network: string;
                };
            };
        };
    }): Resolution;
    /**
     * Creates instance of resolution from provider that implements Ethers Provider#call interface.
     * This wrapper support only `eth_call` method for now, which is enough for all the current Resolution functionality
     * @param networks - an object that describes what network to use when connecting UNS default is mainnet
     * @see https://github.com/ethers-io/ethers.js/blob/v4-legacy/providers/abstract-provider.d.ts#L91
     * @see https://github.com/ethers-io/ethers.js/blob/v5.0.4/packages/abstract-provider/src.ts/index.ts#L224
     * @see https://docs.ethers.io/ethers.js/v5-beta/api-providers.html#jsonrpcprovider-inherits-from-provider
     * @see https://github.com/ethers-io/ethers.js/blob/master/packages/providers/src.ts/json-rpc-provider.ts
     */
    static fromEthersProvider(networks: {
        uns?: {
            locations: {
                Layer1: {
                    network: string;
                    provider: EthersProvider;
                };
                Layer2: {
                    network: string;
                    provider: EthersProvider;
                };
            };
        };
    }): Resolution;
    /**
     * Resolves given domain name to a specific currency address if exists
     * @async
     * @param domain - domain name to be resolved
     * @param ticker - currency ticker like BTC, ETH, ZIL
     * @throws [[ResolutionError]] if address is not found
     * @returns A promise that resolves in an address
     */
    addr(domain: string, ticker: string): Promise<string>;
    /**
     * Read multi-chain currency address if exists
     * @async
     * @param domain - domain name to be resolved
     * @param ticker - currency ticker (USDT, FTM, etc.)
     * @param chain - chain version, usually means blockchain ( ERC20, BEP2, OMNI, etc. )
     * @throws [[ResolutionError]] if address is not found
     * @returns A promise that resolves in an adress
     */
    multiChainAddr(domain: string, ticker: string, chain: string): Promise<string>;
    /**
     * Resolves given domain name to a verified twitter handle
     * @async
     * @param domain - domain name to be resolved
     * @throws [[ResolutionError]] if twitter is not found
     * @returns A promise that resolves in a verified twitter handle
     */
    twitter(domain: string): Promise<string>;
    /**
     * Resolve a chat id from the domain record
     * @param domain - domain name to be resolved
     * @throws [[ResolutionError]]
     * @returns A promise that resolves in chatId
     */
    chatId(domain: string): Promise<string>;
    /**
     * Resolve a gundb public key from the domain record
     * @param domain - domain name to be resolved
     * @throws [[ResolutionError]]
     * @returns a promise that resolves in gundb public key
     */
    chatPk(domain: string): Promise<string>;
    /**
     * Resolves the IPFS hash configured for domain records on ZNS
     * @param domain - domain name
     * @throws [[ResolutionError]]
     */
    ipfsHash(domain: string): Promise<string>;
    /**
     * Resolves the httpUrl attached to domain
     * @param domain - domain name
     */
    httpUrl(domain: string): Promise<string>;
    /**
     * Resolves the ipfs email field from whois configurations
     * @param domain - domain name
     * @throws [[ResolutionError]]
     * @returns A Promise that resolves in an email address configured for this domain whois
     */
    email(domain: string): Promise<string>;
    /**
     * @returns the resolver address for a specific domain
     * @param domain - domain to look for
     */
    resolver(domain: string): Promise<string>;
    /**
     * @param domain - domain name
     * @returns An owner address of the domain
     */
    owner(domain: string): Promise<string | null>;
    /**
     * @param domain - domain name
     * @param recordKey - a name of a record to be resolved
     * @returns A record value promise for a given record name
     */
    record(domain: string, recordKey: string): Promise<string>;
    /**
     * @param domain domain name
     * @param keys Array of record keys to be resolved
     * @returns A Promise with key-value mapping of domain records
     */
    records(domain: string, keys: string[]): Promise<CryptoRecords>;
    /**
     * @param domain domain name
     * @returns A Promise of whether or not the domain belongs to a wallet
     */
    isRegistered(domain: string): Promise<boolean>;
    /**
     * @param domain domain name
     * @returns A Promise of whether or not the domain is available
     */
    isAvailable(domain: string): Promise<boolean>;
    /**
     * @returns Produces a namehash from supported naming service in hex format with 0x prefix.
     * Corresponds to ERC721 token id in case of Ethereum based naming service like UNS.
     * @param domain domain name to be converted
     * @param namingService "UNS" or "ZNS" (uses keccak256 or sha256 algorithm respectively)
     * @param options formatting options
     * @throws [[ResolutionError]] with UnsupportedDomain error code if domain extension is unknown
     */
    namehash(domain: string, namingService: NamingServiceName, options?: NamehashOptions): string;
    /**
     * @returns a namehash of a subdomain with name label
     * @param parent namehash of a parent domain
     * @param label subdomain name
     * @param namingService "UNS" or "ZNS" (uses keccak256 or sha256 algorithm respectively)
     * @param options formatting options
     */
    childhash(parent: string, label: string, namingService: NamingServiceName, options?: NamehashOptions): string;
    private formatNamehash;
    /**
     * Checks weather the domain name matches the hash
     * @param domain - domain name to check against
     * @param hash - hash obtained from the blockchain
     * @param namingService - "UNS" or "ZNS" (uses keccak256 or sha256 algorithm respectively)
     */
    isValidHash(domain: string, hash: string, namingService: NamingServiceName): boolean;
    /**
     * Checks if the domain name is valid according to naming service rules
     * for valid domain names.
     * @param domain - domain name to be checked
     */
    isSupportedDomain(domain: string): Promise<boolean>;
    /**
     * Returns all record keys of the domain.
     * This method is strongly unrecommended for production use due to lack of support for many ethereum service providers and low performance
     * @param domain - domain name
     */
    allRecords(domain: string): Promise<CryptoRecords>;
    allNonEmptyRecords(domain: string): Promise<CryptoRecords>;
    dns(domain: string, types: DnsRecordType[]): Promise<DnsRecord[]>;
    /**
     * Retrieves the tokenURI from the registry smart contract.
     * @returns the ERC721Metadata#tokenURI contract method result
     * @param domain - domain name
     */
    tokenURI(domain: string): Promise<string>;
    /**
     * Retrieves the data from the endpoint provided by tokenURI from the registry smart contract.
     * @returns the JSON response of the token URI endpoint
     * @param domain - domain name
     */
    tokenURIMetadata(domain: string): Promise<TokenUriMetadata>;
    /**
     * Retrieves address of registry contract used for domain
     * @param domain - domain name
     * @returns Registry contract address
     */
    registryAddress(domain: string): Promise<string>;
    /**
     * Retrieves the domain name from tokenId by parsing registry smart contract event logs.
     * @throws {ResolutionError} if returned domain name doesn't match the original namhash.
     * @returns the domain name retrieved from token metadata
     * @param hash - domain hash
     * @param service - nameservice which is used for lookup
     */
    unhash(hash: string, service: NamingServiceName): Promise<string>;
    /**
     * Retrieves address of registry contract used for domain
     * @param domains - domain name
     * @returns Promise<Locations> - A map of domain name and Location (a set of attributes like blockchain,
     */
    locations(domains: string[]): Promise<Locations>;
    /**
     * Returns the token ID that is the primary resolution of the provided address
     * @param address - owner's address
     * @returns Promise<tokenId> - token ID that is the primary resolution of the provided address
     */
    reverseTokenId(address: string, options?: ReverseResolutionOptions): Promise<string>;
    /**
     * Returns the domain that is the primary resolution of the provided address
     * @param address - owner's address
     * @returns Promise<URL> - domain URL that is the primary resolution of the provided addresss
     */
    reverse(address: string, options?: ReverseResolutionOptions): Promise<string | null>;
    private getMetadataFromTokenURI;
    private getDnsRecordKeys;
    private getPreferableNewRecord;
    private callServiceForDomain;
    private callServiceForDomainBoolean;
    private reverseGetTokenId;
}
export { Resolution };
