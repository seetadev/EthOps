"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unwrapResult = exports.wrapResult = exports.EthereumNetworksInverted = exports.EthereumNetworks = exports.findNamingServiceName = exports.domainExtensionToNamingServiceName = exports.constructRecords = exports.isNullAddress = exports.hexToBytes = exports.signedLink = void 0;
var publicTypes_1 = require("../types/publicTypes");
var types_1 = require("../types");
var ProviderURLMap = {
    infura: {
        mainnet: 'https://mainnet.infura.io/v3/',
        rinkeby: 'https://rinkeby.infura.io/v3/',
        goerli: 'https://goerli.infura.io/v3/',
        'polygon-mainnet': 'https://polygon-mainnet.infura.io/v3/',
        'polygon-mumbai': 'https://polygon-mumbai.infura.io/v3/',
    },
    alchemy: {
        mainnet: 'https://eth-mainnet.alchemyapi.io/v2/',
        rinkeby: 'https://eth-rinkeby.alchemyapi.io/v2/',
        goerli: 'https://eth-goerli.alchemyapi.io/v2/',
        'polygon-mainnet': 'https://polygon-mainnet.g.alchemy.com/v2/',
        'polygon-mumbai': 'https://polygon-mumbai.g.alchemy.com/v2/',
    },
};
function signedLink(key, network, provider) {
    if (network === void 0) { network = 'mainnet'; }
    if (provider === void 0) { provider = 'alchemy'; }
    var url = ProviderURLMap[provider][network];
    return "".concat(url).concat(key);
}
exports.signedLink = signedLink;
function hexToBytes(hexString) {
    var hex = hexString.replace(/^0x/i, '');
    var bytes = [];
    for (var c = 0; c < hex.length; c += 2) {
        bytes.push(parseInt(hex.substr(c, 2), 16));
    }
    return bytes;
}
exports.hexToBytes = hexToBytes;
function isNullAddress(key) {
    if (!key) {
        return true;
    }
    return Object.values(types_1.NullAddresses).includes(key);
}
exports.isNullAddress = isNullAddress;
function constructRecords(keys, values) {
    var records = {};
    keys.forEach(function (key, index) {
        records[key] =
            (values instanceof Array ? values[index] : values === null || values === void 0 ? void 0 : values[key]) || '';
    });
    return records;
}
exports.constructRecords = constructRecords;
exports.domainExtensionToNamingServiceName = {
    crypto: publicTypes_1.NamingServiceName.UNS,
    zil: publicTypes_1.NamingServiceName.ZNS,
};
var findNamingServiceName = function (domain) {
    var extension = domain.split('.').pop();
    if (!extension) {
        return '';
    }
    else if (extension in exports.domainExtensionToNamingServiceName) {
        return exports.domainExtensionToNamingServiceName[extension];
    }
    else {
        return exports.domainExtensionToNamingServiceName.crypto;
    }
};
exports.findNamingServiceName = findNamingServiceName;
exports.EthereumNetworks = {
    mainnet: 1,
    ropsten: 3,
    rinkeby: 4,
    goerli: 5,
    'polygon-mainnet': 137,
    'polygon-mumbai': 80001,
};
exports.EthereumNetworksInverted = {
    1: 'mainnet',
    3: 'ropsten',
    4: 'rinkeby',
    5: 'goerli',
    137: 'polygon-mainnet',
    80001: 'polygon-mumbai',
};
var wrapResult = function (func) {
    var callResult;
    // Catch immediately in case it's not an async call.
    try {
        callResult = func();
    }
    catch (error) {
        return Promise.resolve({ result: null, error: error });
    }
    // `Promise.resolve` will convert both promise-like objects and plain values to promises.
    var promise = callResult instanceof Promise ? callResult : Promise.resolve(callResult);
    // We wrap results and errors to avoid unhandled promise rejections in case we won't `await` every promise
    // and return earlier.
    return promise.then(function (result) { return ({ result: result, error: null }); }, function (error) { return ({ result: null, error: error }); });
};
exports.wrapResult = wrapResult;
var unwrapResult = function (wrappedResult) {
    if (wrappedResult.error !== null) {
        throw wrappedResult.error;
    }
    return wrappedResult.result;
};
exports.unwrapResult = unwrapResult;
