"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.recover = exports.hashMessage = void 0;
var js_sha3_1 = require("js-sha3");
var index_1 = require("./index");
var elliptic_1 = require("elliptic");
var secp256k1 = new elliptic_1.ec('secp256k1');
var bytesLength = function (a) { return (a.length - 2) / 2; };
var bytesSlice = function (i, j, bs) {
    return '0x' + bs.slice(i * 2 + 2, j * 2 + 2);
};
var bytesToNumber = function (hex) { return parseInt(hex.slice(2), 16); };
var decodeSignature = function (hex) { return [
    bytesSlice(64, bytesLength(hex), hex),
    bytesSlice(0, 32, hex),
    bytesSlice(32, 64, hex),
]; };
var toChecksum = function (address) {
    var addressHash = (0, js_sha3_1.keccak256)(address.slice(2));
    var checksumAddress = '0x';
    for (var i = 0; i < 40; i++) {
        checksumAddress +=
            parseInt(addressHash[i + 2], 16) > 7
                ? address[i + 2].toUpperCase()
                : address[i + 2];
    }
    return checksumAddress;
};
var hashMessage = function (message) {
    var messageBytes = (0, index_1.hexToBytes)(Buffer.from(message, 'utf8').toString('hex'));
    var messageBuffer = Buffer.from(messageBytes);
    var preamble = '\x19Ethereum Signed Message:\n' + messageBytes.length;
    var preambleBuffer = Buffer.from(preamble);
    var ethMessage = Buffer.concat([preambleBuffer, messageBuffer]);
    return '0x' + (0, js_sha3_1.keccak256)(ethMessage.toString());
};
exports.hashMessage = hashMessage;
var recover = function (message, signature) {
    var hash = (0, exports.hashMessage)(message);
    var vals = decodeSignature(signature);
    var vrs = {
        v: bytesToNumber(vals[0]),
        r: vals[1].slice(2),
        s: vals[2].slice(2),
    };
    var ecPublicKey = secp256k1.recoverPubKey(Buffer.from(hash.slice(2), 'hex'), vrs, vrs.v < 2 ? vrs.v : 1 - (vrs.v % 2));
    var publicKey = '0x' + ecPublicKey.encode('hex', false).slice(2);
    var publicHash = '0x' + (0, js_sha3_1.keccak256)((0, index_1.hexToBytes)(publicKey));
    return toChecksum('0x' + publicHash.slice(-40));
};
exports.recover = recover;
